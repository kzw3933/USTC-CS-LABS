<div style="text-align:center;font-size:2em;font-weight:bold">中国科学技术大学计算机学院</div>

<div style="text-align:center;font-size:2em;font-weight:bold">《数据结构实验报告》</div>





<img src="logo.jpg" style="zoom: 50%;" />





<div style="display: flex;flex-direction: column;align-items: center;font-size:2em">
<div>
<p>实验题目：Huffman编码压缩/解压器</p>
<p>学生姓名：柯志伟</p>
<p>学生学号：PB20061338</p>
<p>完成时间：2022年1月4号</p>
</div>
</div>

<div style="page-break-after:always"></div>

<div style="text-align:center;font-size:1.2em;font-weight:bold">1.实验要求</div>

>基础部分：
	基于 Huffman 编码实现⼀个压缩器和解压缩器（其中 Huffman 编码以字节作为统计和编码的基本符号 单元），使其可以对任意的⽂件进⾏压缩和解压缩操作。针对编译⽣成的	程序，要求压缩和解压缩部分 可以分别独⽴运⾏。具体要求如下：
	- 每次运⾏程序时，⽤⼾可以指定只压缩/只解压缩指定路径的⽂件。实现的时候不限制与⽤⼾的交 互⽅式
	- 压缩时不需要指定解压⽂件的⽬标路径，解压缩时不需要指定压缩前原⽂件的路径，压缩后的⽂件 可以换到另⼀个位置再做解压缩


> 选作部分：
	- 实现可指定的任意基本符号单元⼤小的 Huffman 压缩/解压缩算法
	  - 当基本符号单元的⼤小不再是字节的时候，可能会出现原⽂件本⾝⼤小并⾮基本符号单元⼤小 整数倍的情况，你需要在不改动算法核⼼的前提下解决这个问题，⼀种可能的解决⽅案是将原 ⽂件填充到合适的⼤小，并通过为压缩⽂件的头部增添额外的信息来让你在解压时可以去掉填 充的那部分
	  - 验收时检查以0.5字节和 x(x=0.5k,k介于3与8之间)字节为基本符号单元⼤小的 压缩/解压缩情况，⼆者分别占该加分项 35%、65% 的加分（并⾮完全严格的⽐例，根据实际 情况将作⼀定调整）
	  - 在实验报告中，你也可以尝试统计不同基本符号单元⼤小下的 Huffman 编码压缩/解压缩情 况并试做出分析（不做强制要求）
	- 实现可指定的任意多元 Huffman 压缩/解压缩算法
	  - 该树必须为满的 n 叉树，为此你可能需要在基本符号单元集合中增加权重为 0 的额外的占位 符
	  - 验收时检查指定 3 叉树和x(x介于4,16之间)叉树时的压缩/解压缩情况，要求展⽰⽣ 成的 n 叉 Huffman 树，⼆者分别占该加分项 35%、65% 的加分（并⾮完全严格的⽐例，根 据实际情况将作⼀定调整）
	  - 在实验报告中，你也可以尝试统计不同 n 值下 n 元 Huffman 编码压缩/解压缩情况并试做出 分析（不做强制要求）



<div style="text-align:center;font-size:1.2em;font-weight:bold">2.设计思路</div>

> 基础部分：
	- 总体思路：对文件以单个字节为编码单元，统计编码单元权重，建立Huffman树，从而得到其Huffman编码，用Huffman编码代替原编码从而实现压缩
	- 具体问题及解决思路：
	  - 如何获得编码单元及其权重：对待压缩文件进行两次扫描，第一次建立编码单元的表，第二次获得所有出现的编码单元的出现次数作为权重
	  - 如何建立Huffman树并获得Huffman编码：由于建立的是满二叉树，使用编码单元的权重通过Huffman算法建立Huffman树，再由根节点遍历到各个叶节点(左0右1)获得对应的Huffman编码
	  - 如何通过Huffman编码进行压缩：经过以上的操作只获得了各编码单元的Huffman编码的"01"串，如果直接写入文件肯定无法达到压缩目的，由此压缩文件时读入若干编码单元，获得其对应的"01"串,拼接在一起放入"写入缓存区",每八位转化为1个字节的数，写入文件，如果最后不足，用0补齐
	  - 如何对压缩的文件解压：压缩后在文件中写入编码信息，编码单元及其Huffman编码，解压时先读取编码信息，在读入若干字节，放入"读缓存区"，转化为"01"串，并查找到对应的Huffman编码写入文件，直到写入文件字符数与压缩前相同(在压缩信息中可存入压缩前文件字符数)

> 选作部分：
	- 多字节编码：
	  - 具体问题及解决思路：
	    - 编码单元长度可变：读入文件字符时，将其读入"读缓存区"(存入bit流)，基于编码单元长度划分编码单元，获取编码单元及其编码单元权重，剩余部分与基础部分基本相同
	    - 剩余字符数不足以凑够完整编码单元：这点可通过先扫描一遍文件，获取文件字符数，根据要编码的编码单元长度计算得到有效的编码字符数，剩余字符原样存入压缩文件
	- 多叉树编码
	  - 具体问题及解决思路：
	    - Huffman树的叉数可变：多叉树的Huffman算法与二叉树基本相同，只是每次选取最小的n个节点建立新的节点
	    - 叶节点数不足以建立满n叉数：通过自行添加一些权重为0的空节点凑够满n叉数


<div style="text-align:center;font-size:1.2em;font-weight:bold">3.关键代码讲解</div>



```c
typedef struct CLNode{
	unsigned char ch;
	long weight;
	struct CLNode* next;
}CLNode,*CL;

typedef struct HTNode{
	long weight;
    unsigned char ch;
	long par, lch, rch;
	char* code;
}HTNode;
```

代码中使用的数据结构：Huffman树的节点类型，编码单元链表类型，其中Huffman树的节点信息包括：权重、原编码、Huffman编码、父节点、左右孩子节点，编码单元链表节点包含信息：原编码、权重、指向下一个节点的指针

```c
//读取文件信息：文件长度，文件出现的字符及其出现次数
	//逐字节读取
	FILE* fpin = fopen(FileIn, "rb");
    assert(fpin!=NULL);
	unsigned char ch;
	long flength;
	CL CList = (CL)malloc(sizeof(CLNode));    //带头节点的字符链表
	CList->next = NULL;
	CLNode* pre = CList;

	//创建字符表
	fread(&ch, 1, 1, fpin);
	while (!feof(fpin))
	{
		if (!FindInCL(CList, ch))
		{
			CLNode* node = (CLNode*)malloc(sizeof(CLNode));
			node->ch = ch;
			node->weight = 0;
			node->next = NULL;
			pre-> next = node;
			pre = node;                        //接入字符链表
		}
		fread(&ch, 1, 1, fpin);
	}

	//多次扫描文件获得各字符的权重
	pre = CList->next;
	while (pre)
	{
		fseek(fpin, 0, SEEK_SET);
		fread(&ch, 1, 1, fpin);
		while (!feof(fpin))
		{
			if (ch == pre->ch) pre->weight++;
			fread(&ch, 1, 1, fpin);
		}
		pre = pre->next;
	}


```

建立编码单元链表并获取其权重

```c
//根据创建的字符表及权重创建Huffman树
	long n = LenCL(CList);
	long m = 2 * n - 1;
	HTNode* HTree = (HTNode*)malloc(sizeof(HTNode) * (m + 1)); //带头结点的Huffman节点数组
	pre = CList->next;
    long i,j,k; 
	for (i = 1; i <= n; i++,pre=pre->next)
	{
		(HTree[i]).weight = pre->weight;
		(HTree[i]).code = NULL;
        (HTree[i]).ch = pre->ch;
		(HTree[i]).lch = 0;
		(HTree[i]).rch = 0;
		(HTree[i]).par = 0;
	}
	while (i <= m)
	{
		(HTree[i]).weight = 0;
		(HTree[i]).code = NULL;
        (HTree[i]).ch = '\0';
		(HTree[i]).lch = 0;
		(HTree[i]).rch = 0;
		(HTree[i]).par = 0;                      //初始化Huffman节点数组
        i++;
	}
	for (i = n + 1; i <= m; i++)
	{
		long min = 99999999;
		long k=0;
		for (j = 1; j <= i - 1; j++)
		{
			if (((HTree[j]).weight < min) && ((HTree[j]).par == 0))
			{
				min = (HTree[j]).weight;
				k = j;
			}
		}
		assert(k != 0);                           //确保min初值足够大
		(HTree[i]).weight = (HTree[k]).weight;
		(HTree[i]).lch = k;
		(HTree[k]).par = i;
		min = 99999999;
		k = 0;
		for (j = 1; j <= i - 1; j++)
		{
			if (((HTree[j]).weight < min)&&((HTree[j]).par==0))
			{
				min = (HTree[j]).weight;
				k = j;
			}
		}
		assert(k != 0);                           //确保min初值足够大
		(HTree[i]).weight += (HTree[k]).weight;
		(HTree[i]).rch = k;
		(HTree[k]).par = i;

	}
    //确定各字符对应的Huffman编码
    // FILE* f=fopen("1.txt","w");
    for(i=1;i<=n;i++)
    {
        long end;
        char* code = (char*)malloc(sizeof(char)*(n+1));
        code[n] = '\0';
        j = (HTree[i]).par;
        k = i;
        end = n;
        while(j)
        {
            end--;
            if((HTree[j]).lch == k) code[end] = '0';
            else code[end] = '1';
            k = j;
            j = (HTree[j]).par;
        }
        assert(j==0) ;   
        // char* HUT =  (char*)malloc(sizeof(char)*(n-end+1));
        // strcpy(HUT,&(code[end]));    
        // fprintf(f,"%s\n",HUT); 
        (HTree[i]).code = (char*)malloc(sizeof(char)*(n-end+1));
        strcpy((HTree[i]).code,&(code[end]));
    }
```

建立Huffman树并确定各编码单元对应的Huffman编码

```c
//读取文件并编码
    fseek(fpin,0,SEEK_END);   //将读文件指针置于文件开头
    flength = ftell(fpin);
    fseek(fpin,0,SEEK_SET);
    FILE* fpout = fopen(FileOut,"wb");
    assert(fpout!=NULL);
    fseek(fpout,8,SEEK_SET);  //预留位置，写入文件头


    printf("读取将要压缩的文件：%s,共有字节%d个\n",FileIn,flength);
    printf("正在压缩...\n");

    char buf[512];                 //设定一个缓存区，存储要写入文件的内容
    buf[0] = '\0';
    long rlength=0,wlength=8;
    long LenBuf;
    while(rlength!=flength)
    {
        fread(&ch,1,1,fpin);
        rlength++;
        for(i=1;i<=n;i++)
        {
            if(ch==(HTree[i]).ch) break;
        }
        assert((i>=1)&&(i<=n));
        strcat(buf,(HTree[i]).code);
        LenBuf = strlen(buf);
        ch = 0;
        while(LenBuf>=8)
        {
            for(j=0;j<8;j++)
            {
                if(buf[j] == '1') ch = (ch<<1)|1;
                else ch = ch<<1;
            }
            strcpy(buf,buf+8);
            fwrite(&ch,1,1,fpout);
            wlength++;
            LenBuf = strlen(buf);
        }
    }
    if(LenBuf >0)      //最终剩余字符少于8个
    {
        strcat(buf,"00000000");
        for(i=0;i<8;i++)
        {
            if(buf[i] == '1') ch = (ch<<1)|1;
            else ch = ch<<1;
        }
        fwrite(&ch,1,1,fpout);
        wlength++;
    }

```

读入待压缩文件并编码

```c
 // 写入文件头与编码信息
    fseek(fpout,0,SEEK_SET);
    assert(sizeof(flength) == 4);
    fwrite(&flength,4,1,fpout);
    assert(sizeof(wlength) == 4);
    fwrite(&wlength,4,1,fpout);
    fseek(fpout,wlength,SEEK_SET);
    assert(sizeof(n)==4);
    fwrite(&n,4,1,fpout);
    wlength+=4;
    HTNode Node;
    long LenCode;
    for(i=1;i<=n;i++)
    {
        Node = HTree[i];
        fwrite(&((HTree[i]).ch),1,1,fpout);
        wlength++;
        assert(strlen((HTree[i]).code)<256);
        ch = strlen((HTree[i]).code);
        fwrite(&ch,1,1,fpout);
        wlength++;
        LenCode = strlen((HTree[i]).code);
        if(LenCode%8 != 0)
        {
            for(j=LenCode%8;j<8;j++) strcat((HTree[i]).code,"0");
        }
        while((HTree[i]).code[0] != 0)
        {
            ch = 0;
            for(j=0;j<8;j++)
            {
                if((HTree[i]).code[j]=='1') ch = (ch<<1)|1;
                else ch = ch<<1;
            }
            strcpy((HTree[i]).code,(HTree[i]).code+8);
            fwrite(&ch,1,1,fpout);
            wlength++;
        }
        HTree[i] = Node;
    }
```

写入文件头，文件尾，存入Huffman编码信息

```c
//读取压缩文件，并根据压缩信息构建Huffman树
    long flength,len1,len2;
    long n,m;
    unsigned char ch;
    long LenCode;
    char buf[512];             
    char buf2[512];         //缓存区    
    
    FILE* fpin = fopen(InFile,"rb");
    assert(fpin!=NULL);
    fseek(fpin,0,SEEK_END);
    flength = ftell(fpin);
    fseek(fpin,0,SEEK_SET);
    printf("读取压缩文件:%s,共有字节%d个\n",InFile,flength);
    printf("正在解压...\n");
    fread(&len1,sizeof(long),1,fpin);
    fread(&len2,sizeof(long),1,fpin);
    fseek(fpin,len2,SEEK_SET);
    fread(&n,sizeof(long),1,fpin);
    m = 2*n-1;
    HTNode* HTree = (HTNode*)malloc(sizeof(HTNode) * (m + 1)); //带头结点的Huffman节点数组
    long i,j,k,l;
    // FILE* f = fopen("1.txt","w");
    for(i=1;i<=n;i++)
    {
        fread(&((HTree[i]).ch),1,1,fpin);
        fread(&ch,1,1,fpin);
        LenCode = (long)ch;
        assert(LenCode<256);  //确保后面设立的缓存区不溢出
        (HTree[i]).weight = LenCode;
        (HTree[i]).code =(char*)malloc(sizeof(char)*(LenCode+1));
        (HTree[i]).code[0] = 0;
        if(LenCode%8>0) k=LenCode/8+1;
        else k = LenCode/8;
        for(j=0;j<k;j++)
        {
            fread(&ch,1,1,fpin);
            _itoa(ch,buf,2);
            for(l=8;l>strlen(buf);l--)
            {
                strcat((HTree[i]).code,"0");
            }
            strcat((HTree[i]).code,buf);
        }
        (HTree[i]).code[LenCode] = 0;
        // fprintf(f,"%s\n",(HTree[i]).code);
    }
```

读取压缩文件，并读取压缩信息，重建Huffman树

```c
FILE* fpout = fopen(OutFile,"wb");
    assert(fpout!=NULL);
    long wlength;
    fseek(fpin,8,SEEK_SET);
    buf2[0] = 0;
    while(true)
    {
        while((strlen(buf2) < 256)&&(wlength!=len1))   //确保缓存区不溢出,同时至少读入一个原字符的编码
        {
            fread(&ch,1,1,fpin);
            _itoa(ch,buf,2);
            for(l=8;l>strlen(buf);l--)
            {
                strcat(buf2,"0");
            }
            strcat(buf2,buf);  
        }
        for(i=1;i<n;i++)
        {
            if(memcmp((HTree[i]).code, buf2, (HTree[i]).weight) == 0) break;
        }  
        strcpy(buf2,buf2+(HTree[i]).weight);
        ch = (HTree[i]).ch;
        fwrite(&ch,1,1,fpout);
        wlength++;
        // if(wlength==299990) 
        //         printf("pause");
        
        if(wlength == len1) break;
    }
    fclose(fpin);
    fclose(fpout);
    printf("解压后文件为%s,共有字节%d个\n",OutFile,wlength);
```

根据重建的Huffman树解压压缩文件



<div style="text-align:center;font-size:1.2em;font-weight:bold">4.调试分析</div>

在完成Huffman过程中曾遇到以下问题：
-   二进制文件有些字符无法读入，原先文件打开方式为r，改为rb后解决

- 在反复读取文件时，文件指针未及时修改导致出错

- 在以非整数字节长度的编码单元压缩时，每次读入整数个字节并未用完，但下次直接对其覆盖导致出错
- 缓存区的长度不够导致无法读入一个编码单元或长度太长最后最后无法读满均会陷入死循环
	通过加入判断及单独处理解决

Huffman压缩/解压缩的代码时间复杂度分析(以下以基础部分为例进行分析)：
		编码单元为一个字节，最多编码单元数为256,文件字符数为N，在算法中除文件的读入，写入，主要为查找，比较:
由于不同文件使用的编码单元数不同，以下设其为n
​		1. 获取编码单元数：由于只加入新元素涉及比较，复杂度为N\*n
​		2. 获取编码单元权重：复杂度为N\*n
​		3. 建立Huffman树：叶结点数n，则总结点数为2\*n-1,建树过程为依次选出两个最小权重建立一个新节点，复杂度为n\*n\*2
​		4. 获取Huffman编码：复杂度为n\*n
​		5. 压缩原文件：逐个读入原字符并获得其Huffman编码写入输出文件，复杂度为N\*n\*n
​		6. 重建Huffman树：重建Huffman树只涉及读入编码信息，不涉及比较，查找，不做分析
​		7. 解压缩：读入字符流转化为原字符，每个输出字符都涉及查找，复杂度为N\*n
​		综上：程序的时间复杂度为N*n*n,而n最大为256，故整体复杂度为O(N)
Huffman压缩/解压缩的代码空间复杂度分析：
​		程序使用的内存空间除代码外，涉及字符链表的存储，Huffman树的存储，以及读入、写入文件，由于节点数有限，空间复杂度为O(1)的复杂度




<div style="text-align:center;font-size:1.2em;font-weight:bold">5.代码测试</div>
- 多字节部分：
  ![](D:\Code\CProjects\HuffmanTree\Snipaste_2022-01-06_20-09-13.png)
  原图：logo.jpg
  <img src="D:\Code\CProjects\HuffmanTree\logo.jpg" style="zoom:33%;" />
  压缩恢复后的图：logo_r.jpg
  <img src="D:\Code\CProjects\HuffmanTree\logo_r.jpg" style="zoom:33%;" />
  
- 多叉树部分：
  <img src="D:\Code\CProjects\HuffmanTree\Snipaste_2022-01-06_20-14-19.png" style="zoom:60%;" />
  
  <img src="D:\Code\CProjects\HuffmanTree\Snipaste_2022-01-06_20-14-09.png" style="zoom:60%;" />
  此处打印生成树
  
  <img src="D:\Code\CProjects\HuffmanTree\Snipaste_2022-01-06_20-15-02.png" style="zoom:60%;" />
  原图：logo.jpg
  <img src="D:\Code\CProjects\HuffmanTree\logo.jpg" style="zoom:33%;" />
  压缩恢复后的图：logo_s.jpg
  <img src="D:\Code\CProjects\HuffmanTree\logo_s.jpg" style="zoom:33%;" />



<div style="text-align:center;font-size:1.2em;font-weight:bold">6.实验总结</div>

> ​			通过本次实验更熟悉对文件的操作，熟悉C语言对文件操作的各种方式及可能带来的问题(如遇到某些字符读不出，文件结束符的判定等)，使用树形的数据结构，除此之外，在完成第二个选做时，由于基础部分的生成树不是动态生成的，而是由二叉树叶节点数已知，则节点数已知，用数组实现的静态链表实现二叉树，在多叉树时不具有拓展性，于是用C++重写，改用动态申请内存建立Huffman多叉树，由此，更加了解针对一个抽象数据结构其具体实现依赖于具体的问题要求，依赖于要实现的功能



<div style="text-align:center;font-size:1.2em;font-weight:bold">7.附录</div>
基础部分(C语言)：
HF1.cpp  
选作部分(多字节)：
HF2.cpp  
(多字节+多叉树)(C++)有如下三个文件：
huffman.cpp  函数部分
main.cpp   主函数
huffman.h  头文件
