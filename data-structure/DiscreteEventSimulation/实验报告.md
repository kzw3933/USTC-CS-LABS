<div style="text-align:center;font-size:2em;font-weight:bold">中国科学技术大学计算机学院</div>



<div style="text-align:center;font-size:2em;font-weight:bold">《数据结构实验报告》</div>





<img src="logo.jpg" style="zoom: 50%;" />





<div style="display: flex;flex-direction: column;align-items: center;font-size:2em">
<div>
<p>实验题目：离散事件模拟--电梯</p>
<p>学生姓名：柯志伟</p>
<p>学生学号：PB20061338</p>
<p>完成时间：2022年1月4号</p>
</div>
</div>

<div style="page-break-after:always"></div>

<div style="text-align:center;font-size:1.2em;font-weight:bold">1.实验要求</div>

>基础部分：
	- 模拟某校五层教学楼的电梯系统，该楼有一个自动电梯，能在每层楼停留。五个楼由下至上依次称为地下层，第一层，第二层，第三层和第四层，其中第一层是大楼的进出层，即是电梯的"本垒层"，电梯空闲时会回到本层候命
	- 乘客可随意地进出任何层，对于每个人，有其最长容忍时间，一旦等候时间过长，将会放弃
	- 模拟时钟从0开始，时间单位为0.1秒，人和电梯的各种动作均要耗费一定的时间单位(简记为t),如:有人进出时，电梯每40t测试一次，若无人进出，则关门，关门和开门均需20t，每个人进出电梯均需要25t，如果电梯在某层静止时间达到300t就返回1层候命


> 选作部分：
	- 实现双梯，其余要求与基础部分一致



<div style="text-align:center;font-size:1.2em;font-weight:bold">2.设计思路</div>

> 基础部分：
	- 数据结构：
	  		由于电梯模拟是基于离散事件的模拟，各个事件有事件之间的先后关系，且先发生先处理用队列储存其信息较为合适，基于不同执行主体，将事件分为两类：电梯类和乘客类，两类事件之间有交互，而这些交互是基于当前状态(电梯位置，时间，楼层，乘客)确定的，因此分别设立楼层、电梯的数据结构，包括电梯的乘客栈，楼层的乘客队列等
	- 逻辑部分：
	  电梯模拟是基于事件，涉及事件处理及事件交互：
	  - 事件处理：
	    基于不同执行主体及要完成的具体工作涉及各个事件的处理函数，其中一个难点是：与现实世界可以并行执行同时发生的事件，因此各类事件由不同主体按时间顺序执行就可满足逻辑正确，而电梯模拟只能一件一件处理，因此在处理各类事件时在事件表中搜索同时发生的事件，且优先度更高的先处理，以保证逻辑上更合理
	  - 事件交互：
	    不同类事件间可能有相互触发，因此在事件处理部分要根据当前状态确定是否触发某类事件

​		

> 选作部分：
			与基础部分相比，在于实现两个电梯后，涉及两个电梯间的协调，交互，为保证电梯正常工作，同时不会大量增加交互实现的难度，最好的情况就是两个电梯不需交互就可以协调一致的工作：每一个电梯事件由两个电梯之一具体实现，因此，如果如果事件的执行主体在插入事件表就已经确定就可以实现，而这一点可通过在每产生一个新的电梯事件就进行判断确定(考虑电梯此时行进方向及距事件发生点的距离)，其余部分与基础部分基本一致


<div style="text-align:center;font-size:1.2em;font-weight:bold">3.关键代码讲解</div>



```c
//1.定义必要的数据类型
typedef  enum EventType {EleArivStay,EleBackOne,EleOpen,EleClose,EleOpenOver,EleCloseOver,EleCheck,EleStUp,EleStDown,EleStUpOneFloor,EleStDownOneFloor,EleBackOneDownOneFloor,EleBackOneUpOneFloor,PassAriv,PassGetUpOver,PassGetDownOver,PassGiveUp} EventType;     //事件类型
//注意
//乘客之间互不干扰，电梯与乘客之间有些事件如果同时发生用计算机程序模拟时，涉及判断，需确定处理的程序中顺序 
//也就是说事件具有不同的优先度,对于同时刻发生的事,要保证: 1. 电梯到达停留，乘客到达,先处理电梯到达停留 2.电梯到达停留，乘客放弃,先处理电梯到达停留 3. 电梯检测，乘客到达，先处理乘客到达  4.电梯关闭结束，乘客到达，先处理乘客到达 5.电梯即将返回1楼等待,乘客到达，先处理乘客到达  6.电梯开门结束，乘客到达，先处理乘客到达 7.乘客上电梯结束，另一个乘客到达，先处理乘客到达 

//电梯状态
typedef enum State {GoingUp,GoingDown,Idle,UnKnown} State;    //四种状态，上升，下降，停留，未知
typedef struct Passenger{
    int  infloor;
    int  outfloor;
    int GiveupTime;
}Passenger;
typedef struct PasserNode{
    Passenger passer;
    struct PasserNode * next;
}PasserNode;
typedef struct PasserQuene{
    PasserNode *front;
    PasserNode *rear;
}PasserQuene;            //乘客队列
#define StackInitSize 10
#define StackIncrease  4                                      //栈的相关参数                                     
typedef struct PasserStack{
        Passenger * base;
        Passenger * top;
        int StackSize;                 //当前最大容量
}PasserStack;

typedef struct Elevator{
    int floor;                 //电梯的当前位置
    int D1;                    //值为1时，有人在进入或离开电梯
    int D2;                    //如果电梯在某层等候300t以上
    int D3;                    //值为1时，电梯门开着但没人上电梯
    State statebefore;         //电梯的上一个状态
    State state;               //电梯的状态
    State statenext;           //电梯的上一个状态
    int CallCar[5];             //5个到达楼层信号
    PasserStack passerstack[5];          //5个乘客栈
}Elevator;

typedef struct Buildings{
    int CallUp[5];          
    int CallDown[5];     //分别对应每层楼的上升按钮和下降按钮是否被按亮,楼层共5层，编号0-4
}Buildings;

typedef struct Event{
    int OccurTime;
    EventType type;        //事件类型
    int floor;              //事件发生的楼层,-1,0,1,2,3,4,其中-1代表此处无此标记
}Event;
typedef struct EventNode{
    Event event;              
    struct EventNode *next;
}EventNode,*EventList;         //事件表



```

代码中使用的数据结构：乘客队列，事件队列，楼层，电梯

```c
//主流程函数 
void InitService();
void ElevatorSimulation();
void CloseService();        

//事件表相关函数
void InitEventList(EventList *elptr);
void OrderInsert(Event entmp); 
int  GetCurEvent(Event *enptr);
void DelCurEvent(EventList *EListptr);

//栈相关函数
void InitPasserStack(PasserStack * passerstack);
void StackPush(PasserStack * passerstack,Passenger passertmp);
void StackPop(PasserStack * passerstack,Passenger* passertmp);
int EmptyStack(PasserStack  passerstack);        //栈空返回1，否则返回0

//队列相关函数
void InitQuene(PasserQuene *q);
void EnQuene(PasserQuene * q,Passenger passer);
void DeQuene(PasserQuene * q,Passenger *passer);
int  DelQueneNode(PasserQuene *q, int GiveUpTime);
int  EmptyQuene(PasserQuene q);  


//事件处理相关函数
void HandleCurEvent(Event entmp);
void ShowEvent(Event entmp);

//乘客事件处理函数
void HandlePassAriv(Event entmp);     //优先等级更高，在同时刻发生的事件中优先处理   
void HandlePassGiveUp(Event entmp);     //优先等级更低，在同时刻发生的事件中最次处理    
void HandlePassGetUpOver(Event entmp);          
void HandlePassGetDownOver(Event entmp);         

//电梯事件处理函数
void HandleEleCheck(Event entmp); 
void HandleEleArivStay(Event entmp); 
void HandleEleOpen(Event entmp);
void HandleEleClose(Event entmp);
void HandleEleOpenOver(Event entmp);
void HandleEleCloseOver(Event entmp);

void HandleEleStUp(Event entmp); 
void HandleEleBackOne(Event entmp);        
void HandleEleStDown(Event entmp);  
void HandleEleStDownOneFloor(Event entmp);
void HandleEleStUpOneFloor(Event entmp);
void HandleEleBackOneDownOneFloor(Event entmp);
void HandleEleBackOneUpOneFloor(Event entmp) ;       

//判断下一个要到达的位置
int GetNextFloor(Event entmp);

//判断电梯的下一个状态
State DecideNextState(int floor);

//显示当前状态
void ShowStates();

//随机数函数
void RandomItem(int *InFloor,int *OutFloor,int *GiveupTime,int *InterTime);    

//消除返回1楼事件，一旦电梯服务停止，启动时要保证消除返回1楼事件
void RemoveBackOne(EventList *elptr);

//处理优先性问题
void PriorTasks(Event entmp);

```
代码中各种事件的处理函数

```c
//获取电梯的下一个状态
State DecideNextState(int floor){            //此函数处理电梯处于激活状态，非激活状态特殊考虑 
    switch(elevator.state){
        case GoingUp : return Idle;break;     
        case GoingDown: return Idle;break; 
        case Idle: 
            int i1,i2;
            if(elevator.statebefore==GoingUp){
                for(i1=floor+1;i1<5;i1++){
                    if(elevator.CallCar[i1]==1) return  GoingUp;
                } 
                 for(i1=floor+1;i1<5;i1++){
                    if(Building.CallDown[i1]||Building.CallUp[i1]) return  GoingUp;
                }
                if(Building.CallUp[floor]) return GoingUp;
                if(Building.CallDown[floor]) return GoingDown;
            }
            if(elevator.statebefore==GoingDown){
                for(i2=floor-1;i2>=0;i2--){
                    if(elevator.CallCar[i2]==1)  return GoingDown;
                } 
                 for(i2=floor-1;i2>=0;i2--){
                    if(Building.CallDown[i2]||Building.CallUp[i2]) return  GoingDown;
                }
                
                if(Building.CallDown[floor]) return GoingDown;
                if(Building.CallUp[floor]) return GoingUp;

            }

            return UnKnown;break;
            default: return UnKnown;//用不到，防止编译错误 
            }
    
}
```
​		确定电梯下一刻的状态，从而便于与乘客交互确定相关事件是否触发，需要注意的是，此函数需要在每个涉及交互的事件处理前预先执行，此函数具体实现基于电梯此时的状态及哪层有电梯需求

```c
//获取要去的下一层楼                   //此处逻辑与确定下一个电梯状态略有不同
int GetNextFloor(Event entmp){                                   //此处出错
    int i1,i2,i3;
    int floor;
    switch(elevator.state){
        case GoingDown:
                    for(i1=entmp.floor;i1>=0;i1--){
                        if(elevator.CallCar[i1])  break;
                    }
                    for(i2=entmp.floor;i2>=0;i2--){
                        if(Building.CallDown[i2]) break;
                    }
                    if((i1>=0)&&(i2>=0)){
                      return   (i1>i2? i1:i2);
                    }
                    else if(i1>=0) return  i1;
                    else if(i2>=0) return  i2;
                    else {
                        for(i3=0;i3 <= entmp.floor;i3++){
                            if(Building.CallUp[i3]==1) 
                            return i3;
                    }
                    }
                    return -1;           //正常情况下，不会出现
        case GoingUp:
                    for(i1=entmp.floor;i1<5;i1++){
                        if(elevator.CallCar[i1]==1)  break;
                    }
                    for(i2=entmp.floor;i2<5;i2++){
                        if(Building.CallUp[i2]) 
                            break;
                    }
                    if((i1<5)&&(i2<5)){
                      return (i1<i2? i1:i2);
                    }
                    else if(i1<5)   return i1;
                    else if(i2<5)   return i2;
                    else {
                        for(i3=4;i3>=entmp.floor;i3--){
                        if(Building.CallDown[i3]) 
                            return i3;
                    }
                    }
                    return  -1;   //正常情况下，不会出现
        default :  return -1;          //用不到，防止编译错误 
                                 
    }
   
}
```
​		当电梯在行进时，确定下一个要停留的楼层，相当于确定运动电梯下一时刻的状态，同样与事件触发相关，该函数实现基于当前电梯行进方向及对应方向是否有上下梯的需求进行判断

```c
 void PriorTasks(Event entmp){
    EventNode* entmpNewptr = ev;   //确保电梯到达先处理
    EventNode* entmpNewptr2 ;
    switch (entmp.type){
    case PassAriv: 
                    
                    while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                            if(entmpNewptr->next->event.type == EleArivStay){
                                HandleEleArivStay(entmpNewptr->next->event);
                                entmpNewptr2 = entmpNewptr->next;
                                entmpNewptr->next = entmpNewptr2->next; 
                                free(entmpNewptr2)  ;
                            }
                            else    entmpNewptr = entmpNewptr->next;                               //修改，处理后未删除
                            }  
                            break;
    case  PassGiveUp: 
                       
                        while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                        if(entmpNewptr->next->event.type == EleArivStay){
                            HandleEleArivStay(entmpNewptr->next->event);
                           entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else   entmpNewptr = entmpNewptr->next;
                        } 
                        break;
        case PassGetUpOver:    
               
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;
    
    case EleOpenOver:    
          
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;
    case EleCheck :
            
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;

    case EleCloseOver:
           
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;
    case EleStUpOneFloor: 
            
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;
    case EleStDownOneFloor: 
   
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;
       case EleBackOne: 
            
            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;
        case EleBackOneDownOneFloor: 

                            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break; 
        case EleBackOneUpOneFloor: 

                            while((entmpNewptr->next)&&(entmpNewptr->next->event.OccurTime==entmp.OccurTime)){
                if(entmpNewptr->next->event.type == PassAriv){
                        HandlePassAriv(entmpNewptr->next->event);
                        entmpNewptr2 = entmpNewptr->next;
                            entmpNewptr->next = entmpNewptr2->next; 
                            free(entmpNewptr2)  ;  
                            }
                        else    entmpNewptr = entmpNewptr->next;
                        }
                        break;

    default:        break;
    }
}

```

​		由于同时发生的事件需考虑逻辑上的合理性，在每个事件处理前要预先处理优先度更高的事件，保证: 1. 电梯到达停留，乘客到达,先处理电梯到达停留 2.电梯到达停留，乘客放弃,先处理电梯到达停留 3. 电梯检测，乘客到达，先处理乘客到达  4.电梯关闭结束，乘客到达，先处理乘客到达 5.电梯即将返回1楼等待,乘客到达，先处理乘客到达  6.电梯开门结束，乘客到达，先处理乘客到达 7.乘客上电梯结束，另一个乘客到达，先处理乘客到达
```c
int GetElevator(Passenger passer){
    if(passer.outfloor > passer.infloor){  //乘客上楼
        if(elevator[0].floor <= passer.infloor){
            if(elevator[1].floor<=passer.infloor) {
                if((passer.infloor -elevator[1].floor)<(passer.infloor -elevator[1].floor))
                return 1;
                else return 0;
            }
            else return 0;
        }
        else {
            if(elevator[1].floor <= passer.infloor) return 1;
            else if((elevator[1].floor - passer.infloor)<(elevator[0].floor-passer.infloor)) return 1;
            else return 0;
        }

    }
    else {           //乘客下楼
        if(elevator[0].floor >= passer.infloor){
            if(elevator[1].floor>=passer.infloor) {
                if((elevator[1].floor - passer.infloor)<(elevator[0].floor-passer.infloor))
                        return 1;
                else return 0;
            }
            else return 0;
        }
        else {
            if(elevator[1].floor >= passer.infloor) return 1;
            else if((passer.infloor -elevator[1].floor)<(passer.infloor -elevator[1].floor)) return 1;
            else return 0;
        }

    }

}

```
​		对于双梯部分，确定电梯事件由哪个电梯负责处理

其余部分是各种事件的具体处理部分，不再具述



<div style="text-align:center;font-size:1.2em;font-weight:bold">4.调试分析</div>

在完成电梯的实验中遇到的主要问题有：
  - 事件间的的触发部分处理不当：该触发的事件未触发
  - 同时发生的事件未妥善考虑优先度，导致逻辑不当

电梯实验的时间复杂度：
    电梯服务本身仅涉及事件队列及乘客队列的处理，而乘客的到来是随机的，因而对事件的处理大体只与模拟的规模(模拟的时间)有关，时间复杂度为O(T)，实际上由于每时刻由于可能发生的乘客放弃，预先处理优先度高的事件涉及检索的操作较为耗时，而这些处理与队列长度成正比，而队列长度实际上是动态的，但大体在某个范围内浮动，设平均为L,故时间复杂度为O(L\*T),其中L大体上为O(1)量阶

电梯实验的空间复杂度：
	电梯服务存储的信息涉及电梯状态，楼层状态，各楼层的乘客队列，事件队列，由于随事件处理队列实际上是动态的，但大体在某个范围内浮动，大体上应为O(1)
<div style="text-align:center;font-size:1.2em;font-weight:bold">5.代码测试</div>



代码执行具体效果如下：
- 基础部分：
![](D:\Code\CProjects\DiscreteEventSimulation\Snipaste_2022-01-06_19-31-25.png)
		每当一个事件处理完成时，显示当前的事件，电梯的位置，电梯的当前状态，各个楼层的乘客队列

- 选作部分：
  ![](D:\Code\CProjects\DiscreteEventSimulation\Snipaste_2022-01-06_19-32-05.png)

  ​		每当一个事件处理完成时，显示当前的事件，两个电梯的位置，电梯的当前状态，上一个状态，下一个状态，电梯中的乘客，各个楼层的乘客队列


<div style="text-align:center;font-size:1.2em;font-weight:bold">6.实验总结</div>



> ​	通过模拟电梯服务，具体应用了栈，队列，链表等数据结构，同时了解了事件驱动程序的涉及，同时通过这次实验更深刻理解尽可能将重复性的操作模块化，另外，在处理复杂的逻辑时，"按愿望思维"，先假设已经实现了足够强大的函数完成它，在完成之后的工作后再单独实现这个函数，在本次实验中，先处理优先度高的事件，判断电梯的下一个状态，下一楼层是很多函数的组件，但其逻辑较为复杂，刚开始不易实现，故先使用后实现，除此之外，也提高了自己排错的能力



<div style="text-align:center;font-size:1.2em;font-weight:bold">7.附录</div>

EleSimulation-1.cpp   基础部分

EleSimulation-2.cpp   基础部分(使用另一个状态显示函数)

EleSimulation-3.cpp    选做部分(双梯)
