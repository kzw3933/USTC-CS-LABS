# lab3 实验报告
学号:   PB20061338 
姓名:   柯志伟

## 实验要求

1. 阅读`cminus-f`的语义规则并在此次试验中实现`cminus-f`的语义
2. 阅读并使用`LightIR核心类`
3. 阅读`实验框架`,理解如何使用框架以及注意事项
4. 完成 `src/cminusfc/cminusf_builder.cpp` 来实现 IR 自动产生的算法，使得它能正确编译任何合法的`cminus-f`程序


## 实验难点

本次实验主要为完成对语法树各个节点遍历访问时为产生相应的中间代码所需的访问行为,具体为借助LightIR库接口完成或补全对不同类型节点的访问代码以将cminus-f转换为中间代码,各个部分的实验难点如下:

- ASTProgram
  
已完成，无需操作

- ASTNum
  
借助全局变量tmp_val，创建对应的常量并传递给其他部分使用

- ASTVarDeclaration
1. 区分是数组变量还是非数组变量进行变量的声明创建并添加到当前作用域中
2. 区分是否在全局作用域，全局作用域变量需使用对应变量类型的0初始化

- ASTFunDeclaration

1. 根据函数的返回类型以及参数类型创建对应的函数类型声明并创建对应的函数，同时添加到当前作用域，注意参数类型中无数组类型(产生为对应数组元素类型的指针类型)
2. 维护函数参数类型及对应的store，并添加到当前作用域
3. 递归访问函数体部分

- ASTParam

函数参数部分的操作已在ASTFunDeclaration中完成，无需补充

- ASTCompoundStmt

主体部分已经完成，补全根据是否为初次进入函数体的复合语句来判断是否需要新建立一个作用域部分代码


- ASTExpressionStmt

对其expression部分进行访问

- ASTSelectionStmt

1. 首先对条件表达式部分进行访问，并借助全局变量tmp_val获取条件表达式的值，根据其类型创建对应的与0比较的中间代码指令，据此，产生相应的跳转中间代码
2. 需要判断选择表达式的两种形式(含else或不含else)，产生对应的跳转中间代码

- ASTIterationStmt
主要逻辑与ASTSelectionStmt类似

- ASTReturnStmt

访问其表达式部分，使用全局变量tmp_val获取表达式的值，同时根据当前函数的返回值类型做出需要的类型转化中间代码，最后创建函数返回的中间代码

- ASTVar
1. 需要根据全局变量require_lvalue，判断当前是否需要变量的左值，同时由于对ASTVar的访问可能涉及递归的访问，在本次保存require_lvalue的值后需要将require_lvalue置为无效
2. 根据需要当前变量的左值还是右值，以及当前变量的类型获取对应的值及相应的中间代码，并将值存入全局变量tmp_val中供其余部分使用
3. 需要注意对数组元素的访问不允许下标为负，需要做相应的错误处理函数调用

- ASTAssignExpression

1. 分别对等号左右两边的表达式进行访问，注意访问前对左边的变量要指定全局变量require_lvalue为有效
2. 在创建store指令前，根据左右两边的变量类型做出必要的类型转换

- ASTSimpleExpression

根据操作符生成对应的中间代码，注意在此之前要对表达式两边计算出的值做出必要的类型转换

- ASTAdditiveExpression

主要逻辑与ASTSimpleExpression类似

- ASTTerm
主要逻辑与ASTSimpleExpression类似

- ASTCall
准备函数调用需要的参数，同时检查对应的参数类型，做出必要的类型转换，然后创建对函数调用的中间代码

## 实验设计

- 全局变量

1. 使用tmp_val将表达式的值传递给所需的部分
2. 使用enter_fun_scope表示此次进入ASTCompoundStmt为初入函数体，无需新创建作用域
3. 使用require_lvalue标识需要变量的左值还是右值

### 实验总结

通过此时实验熟悉如何使用访问者模式遍历一棵源代码的语法树产生对应的中间代码，
了解到编译器是如何将高级代码一步步转化成低层次的代码，同时了解到编译器在编译过程中可以为编程人员所作的许多事，产生相应的类型转化，报错信息，一些语法错误的识别，更进一步，很多的高级语言的特性具体是落实到编译器中去实现的。

### 实验反馈 （可选 不计入评分）

暂无
